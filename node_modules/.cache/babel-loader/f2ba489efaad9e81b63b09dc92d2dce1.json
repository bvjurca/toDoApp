{"ast":null,"code":"import _objectSpread from \"/Users/bogdia/IronHack/toDoApp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/bogdia/IronHack/toDoApp/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/bogdia/IronHack/toDoApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { defineStore } from \"pinia\";\nimport supabase from \"../supabase/index\";\nexport default defineStore(\"tasks\", {\n  state: function state() {\n    return {\n      tasks: []\n    };\n  },\n  actions: {\n    addTask: function addTask(taskName, userId, taskStatus) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _yield$supabase$from$, data, _yield$supabase$from$2, error;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return supabase.from(\"tasks\").select(\"title\").match({\n                  title: taskName\n                });\n\n              case 2:\n                _yield$supabase$from$ = _context.sent;\n                data = _yield$supabase$from$.data;\n                _context.next = 6;\n                return supabase.from(\"tasks\").insert([{\n                  title: taskName,\n                  user_id: userId,\n                  is_complete: taskStatus\n                }]);\n\n              case 6:\n                _yield$supabase$from$2 = _context.sent;\n                error = _yield$supabase$from$2.error;\n\n                if (!error) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw error;\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n    timeConv: function timeConv(insertedDate) {\n      //let's convert the supabase date into something more user friendly\n      var msPerMinute = 60 * 1000;\n      var msPerHour = msPerMinute * 60;\n      var msPerDay = msPerHour * 24;\n      var msPerMonth = msPerDay * 30;\n      var msPerYear = msPerDay * 365;\n      var timeAgo = Date.now() - Date.parse(insertedDate);\n\n      if (timeAgo < msPerMinute) {\n        return Math.round(timeAgo / 1000) + \" sec ago\";\n      } else if (timeAgo < msPerHour) {\n        return Math.round(timeAgo / msPerMinute) + \" min ago\";\n      } else if (timeAgo < msPerDay) {\n        return Math.round(timeAgo / msPerHour) + \"h ago\";\n      } else if (timeAgo < msPerMonth) {\n        return \"about \" + Math.round(timeAgo / msPerDay) + \"d ago\";\n      } else if (timeAgo < msPerYear) {\n        return \"about \" + Math.round(timeAgo / msPerMonth) + \" mo ago\";\n      } else {\n        return \"about \" + Math.round(timeAgo / msPerYear) + \"y ago\";\n      }\n    },\n    fetchTasks: function fetchTasks() {\n      var _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _yield$supabase$from$3, tasks;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return supabase.from(\"tasks\").select(\"*\").order(\"id\", {\n                  ascending: false\n                });\n\n              case 2:\n                _yield$supabase$from$3 = _context2.sent;\n                tasks = _yield$supabase$from$3.data;\n                _this.tasks = tasks.map(function (task) {\n                  return _objectSpread(_objectSpread({}, task), {}, {\n                    inserted_at: _this.timeConv(task.inserted_at)\n                  });\n                });\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n    delTask: function delTask(taskId) {\n      var _this2 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _yield$supabase$from$4, data, error, taskIndex;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return supabase.from(\"tasks\")[\"delete\"]().match({\n                  id: taskId\n                });\n\n              case 3:\n                _yield$supabase$from$4 = _context3.sent;\n                data = _yield$supabase$from$4.data;\n                error = _yield$supabase$from$4.error;\n\n                if (!error) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                throw error;\n\n              case 8:\n                if (!(data && data.length)) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                taskIndex = _this2.tasks.findIndex(function (task) {\n                  return task.id === taskId;\n                });\n                _this2.tasks = _this2.tasks.splice(taskIndex, 1);\n                _context3.next = 14;\n                break;\n\n              case 13:\n                throw new Error(\"Task does not exist\");\n\n              case 14:\n                return _context3.abrupt(\"return\", data);\n\n              case 17:\n                _context3.prev = 17;\n                _context3.t0 = _context3[\"catch\"](0);\n                console.error(_context3.t0);\n                return _context3.abrupt(\"return\", null);\n\n              case 21:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[0, 17]]);\n      }))();\n    },\n    editStatus: function editStatus(newStatus, taskId) {\n      var _this3 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _yield$supabase$from$5, error;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return supabase.from(\"tasks\").update({\n                  is_complete: newStatus\n                }).match({\n                  id: taskId\n                });\n\n              case 2:\n                _yield$supabase$from$5 = _context4.sent;\n                error = _yield$supabase$from$5.error;\n\n                if (!error) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw error;\n\n              case 6:\n                _this3.fetchTasks();\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    },\n    editName: function editName(newName, taskId) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _yield$supabase$from$6, error;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return supabase.from(\"tasks\").update({\n                  title: newName\n                }).match({\n                  id: taskId\n                });\n\n              case 2:\n                _yield$supabase$from$6 = _context5.sent;\n                error = _yield$supabase$from$6.error;\n\n                if (!error) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                throw error;\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    }\n  }\n});","map":{"version":3,"names":["defineStore","supabase","state","tasks","actions","addTask","taskName","userId","taskStatus","from","select","match","title","data","insert","user_id","is_complete","error","timeConv","insertedDate","msPerMinute","msPerHour","msPerDay","msPerMonth","msPerYear","timeAgo","Date","now","parse","Math","round","fetchTasks","order","ascending","map","task","inserted_at","delTask","taskId","id","length","taskIndex","findIndex","splice","Error","console","editStatus","newStatus","update","editName","newName"],"sources":["/Users/bogdia/IronHack/toDoApp/src/store/task.js"],"sourcesContent":["import { defineStore } from \"pinia\";\nimport supabase from \"../supabase/index\";\n\nexport default defineStore(\"tasks\", {\n  state: () => ({\n    tasks: [],\n  }),\n  actions: {\n    async addTask(taskName, userId, taskStatus) {\n      const { data } = await supabase\n        .from(\"tasks\")\n        .select(\"title\")\n        .match({ title: taskName });\n      const { error } = await supabase\n        .from(\"tasks\")\n        .insert([\n          { title: taskName, user_id: userId, is_complete: taskStatus },\n        ]);\n      if (error) throw error;\n    },\n    timeConv(insertedDate) {\n      //let's convert the supabase date into something more user friendly\n      var msPerMinute = 60 * 1000;\n      var msPerHour = msPerMinute * 60;\n      var msPerDay = msPerHour * 24;\n      var msPerMonth = msPerDay * 30;\n      var msPerYear = msPerDay * 365;\n\n      var timeAgo = Date.now() - Date.parse(insertedDate);\n      if (timeAgo < msPerMinute) {\n        return Math.round(timeAgo / 1000) + \" sec ago\";\n      } else if (timeAgo < msPerHour) {\n        return Math.round(timeAgo / msPerMinute) + \" min ago\";\n      } else if (timeAgo < msPerDay) {\n        return Math.round(timeAgo / msPerHour) + \"h ago\";\n      } else if (timeAgo < msPerMonth) {\n        return \"about \" + Math.round(timeAgo / msPerDay) + \"d ago\";\n      } else if (timeAgo < msPerYear) {\n        return \"about \" + Math.round(timeAgo / msPerMonth) + \" mo ago\";\n      } else {\n        return \"about \" + Math.round(timeAgo / msPerYear) + \"y ago\";\n      }\n    },\n\n    async fetchTasks() {\n      const { data: tasks } = await supabase\n        .from(\"tasks\")\n        .select(\"*\")\n        .order(\"id\", { ascending: false });\n      this.tasks = tasks.map((task) => ({\n        ...task,\n        inserted_at: this.timeConv(task.inserted_at),\n      }));\n    },\n    async delTask(taskId) {\n      try {\n        const { data, error } = await supabase\n          .from(\"tasks\")\n          .delete()\n          .match({ id: taskId });\n        if (error) throw error;\n        if (data && data.length) {\n          const taskIndex = this.tasks.findIndex((task) => task.id === taskId);\n          this.tasks = this.tasks.splice(taskIndex, 1);\n        } else {\n          throw new Error(\"Task does not exist\");\n        }\n        return data;\n      } catch (error) {\n        console.error(error);\n        return null;\n      }\n    },\n    async editStatus(newStatus, taskId) {\n      const { error } = await supabase\n        .from(\"tasks\")\n        .update({ is_complete: newStatus })\n        .match({ id: taskId });\n      if (error) throw error;\n      this.fetchTasks();\n    },\n    async editName(newName, taskId) {\n      const { error } = await supabase\n        .from(\"tasks\")\n        .update({ title: newName })\n        .match({ id: taskId });\n      if (error) throw error;\n    },\n  },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}